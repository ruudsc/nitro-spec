# nitro-spec

> **Note:** This is a toy project for fun and experimentation. Not intended for production use.

### Installing

Create the OpenAPI plugin at `server/plugins/nitroSpec.ts`:

````typescript
import { createNitroSpecPlugin } from "nitro-spec";

export default defineNitroPlugin((app) => {
  createNitroSpecPlugin({
    app,
    version: "1.0.0",
    title: "My API",
    description: "Type-safe API with automatic documentation",
    baseUrl: "/api",
  });
});
```

### Your First Route

Create `server/routes/users.get.ts`:

```typescript
import { defineMeta, z } from "nitro-spec";

// Define reusable schemas
const UserSchema = z
  .object({
    id: z.string().uuid(),
    name: z.string().min(1),
    email: z.string().email(),
    createdAt: z.string().datetime(),
  })
  .meta({ id: "User" });

// Type-safe route definition
const { defineEventHandler } = defineMeta({
  operationId: "getUsers",
  title: "List Users",
  description: "Retrieve all users with optional filtering",
  query: z.object({
    search: z.string().optional(),
    limit: z.coerce.number().min(1).max(100).default(10),
    offset: z.coerce.number().min(0).default(0),
  }),
  response: z
    .object({
      users: z.array(UserSchema),
      total: z.number(),
      hasMore: z.boolean(),
    })
    .meta({ id: "UserListResponse" }),
});

// Fully typed handler with automatic validation
export default defineEventHandler(async (event, params, query, body) => {
  // query is typed: { search?: string, limit: number, offset: number }
  const users = await getUsersFromDatabase(query);

  return {
    users,
    total: users.length,
    hasMore: query.offset + query.limit < users.length,
  };
});
````

## ğŸ“‚ File-Based Routing

Routes are automatically mapped from your file structure:

```
server/routes/
â”œâ”€â”€ index.get.ts              â†’ GET /
â”œâ”€â”€ users.get.ts              â†’ GET /users
â”œâ”€â”€ users.post.ts             â†’ POST /users
â”œâ”€â”€ users/[id].get.ts         â†’ GET /users/:id
â”œâ”€â”€ users/[id].patch.ts       â†’ PATCH /users/:id
â”œâ”€â”€ api/v1/products.get.ts    â†’ GET /api/v1/products
â””â”€â”€ api/[...slug].get.ts      â†’ GET /api/* (catch-all)
```

## ğŸ›¡ï¸ Advanced Schema Validation

### Path Parameters & Request Bodies

```typescript
// server/routes/users/[id].patch.ts
const UpdateUserSchema = z
  .object({
    name: z.string().min(1).max(100).optional(),
    email: z.string().email().optional(),
  })
  .meta({ id: "UpdateUserRequest" });

const { defineEventHandler } = defineMeta({
  operationId: "updateUser",
  title: "Update User",
  path: z.object({
    id: z.string().uuid(), // Validates route parameter
  }),
  body: UpdateUserSchema,
  responses: {
    200: UserSchema,
    404: z.object({ message: z.string() }).meta({ id: "NotFound" }),
    400: z
      .object({ message: z.string(), errors: z.array(z.string()) })
      .meta({ id: "ValidationError" }),
  },
});

export default defineEventHandler(async (event, params, query, body) => {
  // params.id is typed as string and validated as UUID
  // body is typed as Partial<UpdateUserRequest> and validated

  const user = await updateUser(params.id, body);

  if (!user) {
    throw createError({
      statusCode: 404,
      statusMessage: "User not found",
    });
  }

  return user;
});
```

## ğŸ”§ Middleware System

> **Note:** `@nitro-spec/middlewares` package is still in development and not yet stable.

### Custom Middleware Example

You can define your own middleware functions and use them with `defineMeta`. Custom middleware enables authentication, logging, validation, and more.

```typescript
import { defineMeta } from "nitro-spec";

// Example custom middleware
const auditMiddleware = {
  type: "custom",
  name: "audit-logger",
  handler: async (event) => {
    // Custom audit logic
    const userId = event.context.user?.id;
    const action = `${event.node.req.method} ${event.node.req.url}`;
    await logAuditEvent({ userId, action, timestamp: new Date() });
  },
};

const { defineEventHandler } = defineMeta({
  operationId: "getProtectedData",
  middleware: [auditMiddleware],
  response: z.object({ data: z.string() }).meta({ id: "ProtectedData" }),
});
```

### Custom Middleware

```typescript
import { createCustomMiddleware } from "@nitro-spec/middlewares";

const auditMiddleware = createCustomMiddleware(
  "audit-logger",
  async (event) => {
    const userId = event.context.user?.id;
    const action = `${event.node.req.method} ${event.node.req.url}`;

    await logAuditEvent({ userId, action, timestamp: new Date() });
  },
  "Logs user actions for compliance",
);
```

## ğŸ“– Automatic Documentation

Once configured, your API documentation is automatically available:

- **Scalar UI**: `http://localhost:3000/api/openapi`
- **ReDoc**: `http://localhost:3000/api/openapi/redoc`
- **JSON Spec**: `http://localhost:3000/api/openapi.json`
- **YAML Spec**: `http://localhost:3000/api/openapi.yaml`

## ğŸ—ï¸ Architecture

### Monorepo Structure

```
nitro-spec/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ nitro-spec/              # Core library
â”‚   â””â”€â”€ nitro-spec-middlewares/  # Middleware collection
â””â”€â”€ playground/
    â””â”€â”€ nitro-app/              # Example application
```

### Build-Time Magic

- **Route scanning**: Automatically extracts method and path from file structure
- **Type generation**: Creates TypeScript definitions from Zod schemas
- **OpenAPI compilation**: Generates specification during build process
- **Tree-shaking**: Only includes used middleware and schemas

## ğŸ¯ Best Practices

### Schema Organization

```typescript
// schemas/user.ts - Centralized schema definitions
export const UserSchema = z
  .object({
    id: z.string().uuid(),
    name: z.string().min(1),
    email: z.string().email(),
  })
  .meta({ id: "User" });

export const CreateUserSchema = UserSchema.omit({ id: true }).meta({
  id: "CreateUser",
});
export const UpdateUserSchema = CreateUserSchema.partial().meta({
  id: "UpdateUser",
});
```

### Error Handling

```typescript
// utils/errors.ts - Consistent error schemas
export const ErrorSchemas = {
  400: z
    .object({ message: z.string(), field: z.string().optional() })
    .meta({ id: "BadRequest" }),
  401: z.object({ message: z.string() }).meta({ id: "Unauthorized" }),
  404: z.object({ message: z.string() }).meta({ id: "NotFound" }),
  500: z.object({ error: z.string() }).meta({ id: "ServerError" }),
};
```

### Reusable Middleware Stack

```typescript
// middleware/common.ts
export const commonMiddleware = [
  createLoggingMiddleware("api-logger"),
  createCORSMiddleware({ origin: process.env.ALLOWED_ORIGINS?.split(",") }),
  createRateLimitMiddleware({ windowMs: 60000, maxRequests: 100 }),
];
```

## ğŸ“š Ecosystem

## ğŸ†• Migration from v7

If you're upgrading from `@asteasolutions/zod-to-openapi` v7:

```typescript
// Before (v7)
const UserSchema = z
  .object({
    id: z.string(),
    name: z.string(),
  })
  .openapi("User");

// After (v8)
const UserSchema = z
  .object({
    id: z.string(),
    name: z.string(),
  })
  .meta({ id: "User" });
```
